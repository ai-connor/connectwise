/*
Connectwise Manage Public Endpoints

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2025.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cwapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CatalogsItemAPIService CatalogsItemAPI service
type CatalogsItemAPIService service

type ApiDeleteProcurementCatalogByIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
}

// 
func (r ApiDeleteProcurementCatalogByIdRequest) ClientId(clientId string) ApiDeleteProcurementCatalogByIdRequest {
	r.clientId = &clientId
	return r
}

func (r ApiDeleteProcurementCatalogByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProcurementCatalogByIdExecute(r)
}

/*
DeleteProcurementCatalogById Delete CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiDeleteProcurementCatalogByIdRequest
*/
func (a *CatalogsItemAPIService) DeleteProcurementCatalogById(ctx context.Context, id int32) ApiDeleteProcurementCatalogByIdRequest {
	return ApiDeleteProcurementCatalogByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsItemAPIService) DeleteProcurementCatalogByIdExecute(r ApiDeleteProcurementCatalogByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.DeleteProcurementCatalogById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return nil, reportError("clientId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	parentId int32
	id int32
	clientId *string
}

// 
func (r ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest) ClientId(clientId string) ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest {
	r.clientId = &clientId
	return r
}

func (r ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProcurementCatalogByParentIdVendorsByIdExecute(r)
}

/*
DeleteProcurementCatalogByParentIdVendorsById Delete CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentId catalogId
 @param id vendorId
 @return ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest
*/
func (a *CatalogsItemAPIService) DeleteProcurementCatalogByParentIdVendorsById(ctx context.Context, parentId int32, id int32) ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest {
	return ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest{
		ApiService: a,
		ctx: ctx,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsItemAPIService) DeleteProcurementCatalogByParentIdVendorsByIdExecute(r ApiDeleteProcurementCatalogByParentIdVendorsByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.DeleteProcurementCatalogByParentIdVendorsById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{parentId}/vendors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterValueToString(r.parentId, "parentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return nil, reportError("clientId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogRequest) ClientId(clientId string) ApiGetProcurementCatalogRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) Conditions(conditions string) ApiGetProcurementCatalogRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) OrderBy(orderBy string) ApiGetProcurementCatalogRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) Fields(fields string) ApiGetProcurementCatalogRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) Page(page int32) ApiGetProcurementCatalogRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) PageSize(pageSize int32) ApiGetProcurementCatalogRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogRequest) PageId(pageId int32) ApiGetProcurementCatalogRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogRequest) Execute() ([]CatalogItem, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogExecute(r)
}

/*
GetProcurementCatalog Get List of CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcurementCatalogRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalog(ctx context.Context) ApiGetProcurementCatalogRequest {
	return ApiGetProcurementCatalogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CatalogItem
func (a *CatalogsItemAPIService) GetProcurementCatalogExecute(r ApiGetProcurementCatalogRequest) ([]CatalogItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	catalogItemIdentifier string
	clientId *string
	warehouseBinId int32
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) ClientId(clientId string) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) Conditions(conditions string) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) OrderBy(orderBy string) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) Fields(fields string) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) Page(page int32) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) PageSize(pageSize int32) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) PageId(pageId int32) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) Execute() (*Count, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogByCatalogItemIdentifierQuantityOnHandExecute(r)
}

/*
GetProcurementCatalogByCatalogItemIdentifierQuantityOnHand Get Count of CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogItemIdentifier catalogItemIdentifier
 @param warehouseBinId warehouseBinId
 @return ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogByCatalogItemIdentifierQuantityOnHand(ctx context.Context, catalogItemIdentifier string, warehouseBinId int32) ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest {
	return ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest{
		ApiService: a,
		ctx: ctx,
		catalogItemIdentifier: catalogItemIdentifier,
		warehouseBinId: warehouseBinId,
	}
}

// Execute executes the request
//  @return Count
func (a *CatalogsItemAPIService) GetProcurementCatalogByCatalogItemIdentifierQuantityOnHandExecute(r ApiGetProcurementCatalogByCatalogItemIdentifierQuantityOnHandRequest) (*Count, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Count
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogByCatalogItemIdentifierQuantityOnHand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{catalogItemIdentifier}/quantityOnHand"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogItemIdentifier"+"}", url.PathEscape(parameterValueToString(r.catalogItemIdentifier, "catalogItemIdentifier")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"warehouseBinId"+"}", url.PathEscape(parameterValueToString(r.warehouseBinId, "warehouseBinId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogByIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogByIdRequest) ClientId(clientId string) ApiGetProcurementCatalogByIdRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) Conditions(conditions string) ApiGetProcurementCatalogByIdRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogByIdRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogByIdRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) OrderBy(orderBy string) ApiGetProcurementCatalogByIdRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) Fields(fields string) ApiGetProcurementCatalogByIdRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) Page(page int32) ApiGetProcurementCatalogByIdRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) PageSize(pageSize int32) ApiGetProcurementCatalogByIdRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogByIdRequest) PageId(pageId int32) ApiGetProcurementCatalogByIdRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogByIdRequest) Execute() (*CatalogItem, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogByIdExecute(r)
}

/*
GetProcurementCatalogById Get CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiGetProcurementCatalogByIdRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogById(ctx context.Context, id int32) ApiGetProcurementCatalogByIdRequest {
	return ApiGetProcurementCatalogByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CatalogItem
func (a *CatalogsItemAPIService) GetProcurementCatalogByIdExecute(r ApiGetProcurementCatalogByIdRequest) (*CatalogItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogByIdInfoRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) ClientId(clientId string) ApiGetProcurementCatalogByIdInfoRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) Conditions(conditions string) ApiGetProcurementCatalogByIdInfoRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogByIdInfoRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogByIdInfoRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) OrderBy(orderBy string) ApiGetProcurementCatalogByIdInfoRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) Fields(fields string) ApiGetProcurementCatalogByIdInfoRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) Page(page int32) ApiGetProcurementCatalogByIdInfoRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) PageSize(pageSize int32) ApiGetProcurementCatalogByIdInfoRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogByIdInfoRequest) PageId(pageId int32) ApiGetProcurementCatalogByIdInfoRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogByIdInfoRequest) Execute() (*CatalogItemInfo, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogByIdInfoExecute(r)
}

/*
GetProcurementCatalogByIdInfo Get CatalogItemInfo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiGetProcurementCatalogByIdInfoRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogByIdInfo(ctx context.Context, id int32) ApiGetProcurementCatalogByIdInfoRequest {
	return ApiGetProcurementCatalogByIdInfoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CatalogItemInfo
func (a *CatalogsItemAPIService) GetProcurementCatalogByIdInfoExecute(r ApiGetProcurementCatalogByIdInfoRequest) (*CatalogItemInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogItemInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogByIdInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogCountRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogCountRequest) ClientId(clientId string) ApiGetProcurementCatalogCountRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) Conditions(conditions string) ApiGetProcurementCatalogCountRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogCountRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogCountRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) OrderBy(orderBy string) ApiGetProcurementCatalogCountRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) Fields(fields string) ApiGetProcurementCatalogCountRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) Page(page int32) ApiGetProcurementCatalogCountRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) PageSize(pageSize int32) ApiGetProcurementCatalogCountRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogCountRequest) PageId(pageId int32) ApiGetProcurementCatalogCountRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogCountRequest) Execute() (*Count, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogCountExecute(r)
}

/*
GetProcurementCatalogCount Get Count of CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcurementCatalogCountRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogCount(ctx context.Context) ApiGetProcurementCatalogCountRequest {
	return ApiGetProcurementCatalogCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Count
func (a *CatalogsItemAPIService) GetProcurementCatalogCountExecute(r ApiGetProcurementCatalogCountRequest) (*Count, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Count
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogInfoRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogInfoRequest) ClientId(clientId string) ApiGetProcurementCatalogInfoRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) Conditions(conditions string) ApiGetProcurementCatalogInfoRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogInfoRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogInfoRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) OrderBy(orderBy string) ApiGetProcurementCatalogInfoRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) Fields(fields string) ApiGetProcurementCatalogInfoRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) Page(page int32) ApiGetProcurementCatalogInfoRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) PageSize(pageSize int32) ApiGetProcurementCatalogInfoRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogInfoRequest) PageId(pageId int32) ApiGetProcurementCatalogInfoRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogInfoRequest) Execute() ([]CatalogItemInfo, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogInfoExecute(r)
}

/*
GetProcurementCatalogInfo Get List of CatalogItemInfo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcurementCatalogInfoRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogInfo(ctx context.Context) ApiGetProcurementCatalogInfoRequest {
	return ApiGetProcurementCatalogInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CatalogItemInfo
func (a *CatalogsItemAPIService) GetProcurementCatalogInfoExecute(r ApiGetProcurementCatalogInfoRequest) ([]CatalogItemInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CatalogItemInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogInfoCountRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) ClientId(clientId string) ApiGetProcurementCatalogInfoCountRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) Conditions(conditions string) ApiGetProcurementCatalogInfoCountRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogInfoCountRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogInfoCountRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) OrderBy(orderBy string) ApiGetProcurementCatalogInfoCountRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) Fields(fields string) ApiGetProcurementCatalogInfoCountRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) Page(page int32) ApiGetProcurementCatalogInfoCountRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) PageSize(pageSize int32) ApiGetProcurementCatalogInfoCountRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogInfoCountRequest) PageId(pageId int32) ApiGetProcurementCatalogInfoCountRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogInfoCountRequest) Execute() (*Count, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogInfoCountExecute(r)
}

/*
GetProcurementCatalogInfoCount Get Count of CatalogItemInfo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProcurementCatalogInfoCountRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogInfoCount(ctx context.Context) ApiGetProcurementCatalogInfoCountRequest {
	return ApiGetProcurementCatalogInfoCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Count
func (a *CatalogsItemAPIService) GetProcurementCatalogInfoCountExecute(r ApiGetProcurementCatalogInfoCountRequest) (*Count, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Count
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogInfoCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/info/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProcurementCatalogVendorsByParentIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	parentId int32
	clientId *string
	conditions *string
	childConditions *string
	customFieldConditions *string
	orderBy *string
	fields *string
	page *int32
	pageSize *int32
	pageId *int32
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) ClientId(clientId string) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.clientId = &clientId
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) Conditions(conditions string) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.conditions = &conditions
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) ChildConditions(childConditions string) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.childConditions = &childConditions
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) CustomFieldConditions(customFieldConditions string) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.customFieldConditions = &customFieldConditions
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) OrderBy(orderBy string) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.orderBy = &orderBy
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) Fields(fields string) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.fields = &fields
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) Page(page int32) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.page = &page
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) PageSize(pageSize int32) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.pageSize = &pageSize
	return r
}

// 
func (r ApiGetProcurementCatalogVendorsByParentIdRequest) PageId(pageId int32) ApiGetProcurementCatalogVendorsByParentIdRequest {
	r.pageId = &pageId
	return r
}

func (r ApiGetProcurementCatalogVendorsByParentIdRequest) Execute() ([]CatalogVendors, *http.Response, error) {
	return r.ApiService.GetProcurementCatalogVendorsByParentIdExecute(r)
}

/*
GetProcurementCatalogVendorsByParentId Get List of CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentId vendorId
 @return ApiGetProcurementCatalogVendorsByParentIdRequest
*/
func (a *CatalogsItemAPIService) GetProcurementCatalogVendorsByParentId(ctx context.Context, parentId int32) ApiGetProcurementCatalogVendorsByParentIdRequest {
	return ApiGetProcurementCatalogVendorsByParentIdRequest{
		ApiService: a,
		ctx: ctx,
		parentId: parentId,
	}
}

// Execute executes the request
//  @return []CatalogVendors
func (a *CatalogsItemAPIService) GetProcurementCatalogVendorsByParentIdExecute(r ApiGetProcurementCatalogVendorsByParentIdRequest) ([]CatalogVendors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CatalogVendors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.GetProcurementCatalogVendorsByParentId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/vendors/{parentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterValueToString(r.parentId, "parentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	if r.conditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditions", r.conditions, "form", "")
	}
	if r.childConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childConditions", r.childConditions, "form", "")
	}
	if r.customFieldConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customFieldConditions", r.customFieldConditions, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchProcurementCatalogByIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
	patchOperation *[]PatchOperation
}

// 
func (r ApiPatchProcurementCatalogByIdRequest) ClientId(clientId string) ApiPatchProcurementCatalogByIdRequest {
	r.clientId = &clientId
	return r
}

// List of PatchOperation
func (r ApiPatchProcurementCatalogByIdRequest) PatchOperation(patchOperation []PatchOperation) ApiPatchProcurementCatalogByIdRequest {
	r.patchOperation = &patchOperation
	return r
}

func (r ApiPatchProcurementCatalogByIdRequest) Execute() (*CatalogItem, *http.Response, error) {
	return r.ApiService.PatchProcurementCatalogByIdExecute(r)
}

/*
PatchProcurementCatalogById Patch CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiPatchProcurementCatalogByIdRequest
*/
func (a *CatalogsItemAPIService) PatchProcurementCatalogById(ctx context.Context, id int32) ApiPatchProcurementCatalogByIdRequest {
	return ApiPatchProcurementCatalogByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CatalogItem
func (a *CatalogsItemAPIService) PatchProcurementCatalogByIdExecute(r ApiPatchProcurementCatalogByIdRequest) (*CatalogItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PatchProcurementCatalogById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.patchOperation == nil {
		return localVarReturnValue, nil, reportError("patchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	// body params
	localVarPostBody = r.patchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProcurementCatalogRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	clientId *string
	catalogItem *CatalogItem
}

// 
func (r ApiPostProcurementCatalogRequest) ClientId(clientId string) ApiPostProcurementCatalogRequest {
	r.clientId = &clientId
	return r
}

// catalogItem
func (r ApiPostProcurementCatalogRequest) CatalogItem(catalogItem CatalogItem) ApiPostProcurementCatalogRequest {
	r.catalogItem = &catalogItem
	return r
}

func (r ApiPostProcurementCatalogRequest) Execute() (*CatalogItem, *http.Response, error) {
	return r.ApiService.PostProcurementCatalogExecute(r)
}

/*
PostProcurementCatalog Post CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostProcurementCatalogRequest
*/
func (a *CatalogsItemAPIService) PostProcurementCatalog(ctx context.Context) ApiPostProcurementCatalogRequest {
	return ApiPostProcurementCatalogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatalogItem
func (a *CatalogsItemAPIService) PostProcurementCatalogExecute(r ApiPostProcurementCatalogRequest) (*CatalogItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PostProcurementCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.catalogItem == nil {
		return localVarReturnValue, nil, reportError("catalogItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	// body params
	localVarPostBody = r.catalogItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProcurementCatalogByIdCopyRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
}

// 
func (r ApiPostProcurementCatalogByIdCopyRequest) ClientId(clientId string) ApiPostProcurementCatalogByIdCopyRequest {
	r.clientId = &clientId
	return r
}

func (r ApiPostProcurementCatalogByIdCopyRequest) Execute() (*CatalogItem, *http.Response, error) {
	return r.ApiService.PostProcurementCatalogByIdCopyExecute(r)
}

/*
PostProcurementCatalogByIdCopy Post Copy CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiPostProcurementCatalogByIdCopyRequest
*/
func (a *CatalogsItemAPIService) PostProcurementCatalogByIdCopy(ctx context.Context, id int32) ApiPostProcurementCatalogByIdCopyRequest {
	return ApiPostProcurementCatalogByIdCopyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CatalogItem
func (a *CatalogsItemAPIService) PostProcurementCatalogByIdCopyExecute(r ApiPostProcurementCatalogByIdCopyRequest) (*CatalogItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PostProcurementCatalogByIdCopy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProcurementCatalogByIdPricingRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
	catalogPricing *CatalogPricing
}

// 
func (r ApiPostProcurementCatalogByIdPricingRequest) ClientId(clientId string) ApiPostProcurementCatalogByIdPricingRequest {
	r.clientId = &clientId
	return r
}

// catalogPricing
func (r ApiPostProcurementCatalogByIdPricingRequest) CatalogPricing(catalogPricing CatalogPricing) ApiPostProcurementCatalogByIdPricingRequest {
	r.catalogPricing = &catalogPricing
	return r
}

func (r ApiPostProcurementCatalogByIdPricingRequest) Execute() (*CatalogPricing, *http.Response, error) {
	return r.ApiService.PostProcurementCatalogByIdPricingExecute(r)
}

/*
PostProcurementCatalogByIdPricing Post CatalogPricing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiPostProcurementCatalogByIdPricingRequest
*/
func (a *CatalogsItemAPIService) PostProcurementCatalogByIdPricing(ctx context.Context, id int32) ApiPostProcurementCatalogByIdPricingRequest {
	return ApiPostProcurementCatalogByIdPricingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CatalogPricing
func (a *CatalogsItemAPIService) PostProcurementCatalogByIdPricingExecute(r ApiPostProcurementCatalogByIdPricingRequest) (*CatalogPricing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogPricing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PostProcurementCatalogByIdPricing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.catalogPricing == nil {
		return localVarReturnValue, nil, reportError("catalogPricing is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	// body params
	localVarPostBody = r.catalogPricing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProcurementCatalogVendorsRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	clientId *string
	catalogVendors *CatalogVendors
}

// 
func (r ApiPostProcurementCatalogVendorsRequest) ClientId(clientId string) ApiPostProcurementCatalogVendorsRequest {
	r.clientId = &clientId
	return r
}

// catalogVendors
func (r ApiPostProcurementCatalogVendorsRequest) CatalogVendors(catalogVendors CatalogVendors) ApiPostProcurementCatalogVendorsRequest {
	r.catalogVendors = &catalogVendors
	return r
}

func (r ApiPostProcurementCatalogVendorsRequest) Execute() (*CatalogVendors, *http.Response, error) {
	return r.ApiService.PostProcurementCatalogVendorsExecute(r)
}

/*
PostProcurementCatalogVendors Post CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostProcurementCatalogVendorsRequest
*/
func (a *CatalogsItemAPIService) PostProcurementCatalogVendors(ctx context.Context) ApiPostProcurementCatalogVendorsRequest {
	return ApiPostProcurementCatalogVendorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatalogVendors
func (a *CatalogsItemAPIService) PostProcurementCatalogVendorsExecute(r ApiPostProcurementCatalogVendorsRequest) (*CatalogVendors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogVendors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PostProcurementCatalogVendors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/vendors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.catalogVendors == nil {
		return localVarReturnValue, nil, reportError("catalogVendors is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	// body params
	localVarPostBody = r.catalogVendors
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutProcurementCatalogByIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	clientId *string
	catalogItem *CatalogItem
}

// 
func (r ApiPutProcurementCatalogByIdRequest) ClientId(clientId string) ApiPutProcurementCatalogByIdRequest {
	r.clientId = &clientId
	return r
}

// catalogItem
func (r ApiPutProcurementCatalogByIdRequest) CatalogItem(catalogItem CatalogItem) ApiPutProcurementCatalogByIdRequest {
	r.catalogItem = &catalogItem
	return r
}

func (r ApiPutProcurementCatalogByIdRequest) Execute() (*CatalogItem, *http.Response, error) {
	return r.ApiService.PutProcurementCatalogByIdExecute(r)
}

/*
PutProcurementCatalogById Put CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id catalogId
 @return ApiPutProcurementCatalogByIdRequest
*/
func (a *CatalogsItemAPIService) PutProcurementCatalogById(ctx context.Context, id int32) ApiPutProcurementCatalogByIdRequest {
	return ApiPutProcurementCatalogByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CatalogItem
func (a *CatalogsItemAPIService) PutProcurementCatalogByIdExecute(r ApiPutProcurementCatalogByIdRequest) (*CatalogItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PutProcurementCatalogById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.catalogItem == nil {
		return localVarReturnValue, nil, reportError("catalogItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	// body params
	localVarPostBody = r.catalogItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutProcurementCatalogByParentIdVendorsByIdRequest struct {
	ctx context.Context
	ApiService *CatalogsItemAPIService
	id int32
	parentId int32
	clientId *string
	catalogItem *CatalogItem
}

// 
func (r ApiPutProcurementCatalogByParentIdVendorsByIdRequest) ClientId(clientId string) ApiPutProcurementCatalogByParentIdVendorsByIdRequest {
	r.clientId = &clientId
	return r
}

// catalogItem
func (r ApiPutProcurementCatalogByParentIdVendorsByIdRequest) CatalogItem(catalogItem CatalogItem) ApiPutProcurementCatalogByParentIdVendorsByIdRequest {
	r.catalogItem = &catalogItem
	return r
}

func (r ApiPutProcurementCatalogByParentIdVendorsByIdRequest) Execute() (*CatalogVendors, *http.Response, error) {
	return r.ApiService.PutProcurementCatalogByParentIdVendorsByIdExecute(r)
}

/*
PutProcurementCatalogByParentIdVendorsById Put CatalogItem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id vendorId
 @param parentId catalogId
 @return ApiPutProcurementCatalogByParentIdVendorsByIdRequest
*/
func (a *CatalogsItemAPIService) PutProcurementCatalogByParentIdVendorsById(ctx context.Context, id int32, parentId int32) ApiPutProcurementCatalogByParentIdVendorsByIdRequest {
	return ApiPutProcurementCatalogByParentIdVendorsByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		parentId: parentId,
	}
}

// Execute executes the request
//  @return CatalogVendors
func (a *CatalogsItemAPIService) PutProcurementCatalogByParentIdVendorsByIdExecute(r ApiPutProcurementCatalogByParentIdVendorsByIdRequest) (*CatalogVendors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogVendors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsItemAPIService.PutProcurementCatalogByParentIdVendorsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/procurement/catalog/{parentId}/vendors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterValueToString(r.parentId, "parentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.catalogItem == nil {
		return localVarReturnValue, nil, reportError("catalogItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.connectwise.com+json; version=2025.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "clientId", r.clientId, "simple", "")
	// body params
	localVarPostBody = r.catalogItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
